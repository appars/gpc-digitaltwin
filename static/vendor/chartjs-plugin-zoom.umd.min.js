(function (root, factory) {
  if (typeof define === 'function' && define.amd) {
    define(['chart.js'], factory);
  } else if (typeof module === 'object' && module.exports) {
    module.exports = factory(require('chart.js'));
  } else {
    root['chartjs-plugin-zoom'] = factory(root.Chart);
  }
}(this, function (Chart) {
  if (!Chart) { return {}; }

  const S = new WeakMap(); // per-chart state

  function getOpts(chart){
    const z = (((chart.options||{}).plugins||{}).zoom)||{};
    const zoom = (z.zoom||{}), pan = (z.pan||{});
    return {
      zoomEnabled: !!(zoom.wheel && zoom.wheel.enabled),
      panEnabled:  !!pan.enabled,
      mode: (zoom.mode || pan.mode || 'x') // 'x' | 'y' | 'xy'
    };
  }

  function getScales(chart, mode){
    const x = chart.scales['x'];
    const y = chart.scales['y'] || chart.scales['r'] || chart.scales['y1'];
    return {
      x: (mode.includes('x') && x && x.type !== 'radialLinear') ? x : null,
      y: (mode.includes('y') && y && y.type !== 'radialLinear') ? y : null
    };
  }

  function clamp(v, a, b){ return Math.min(b, Math.max(a, v)); }

  function storeInitial(chart){
    const st = S.get(chart) || {};
    const sx = chart.scales['x'], sy = chart.scales['y'] || chart.scales['y1'];
    if (sx && st.initX == null) st.initX = {min: sx.min, max: sx.max};
    if (sy && st.initY == null) st.initY = {min: sy.min, max: sy.max};
    S.set(chart, st);
  }

  function setRange(scale, min, max){
    const o = scale.options;
    o.min = min; o.max = max;
  }

  function pixelToValue(scale, px){
    try { return scale.getValueForPixel(px); } catch { return null; }
  }
  function valueToPixel(scale, v){
    try { return scale.getPixelForValue(v); } catch { return null; }
  }

  function wheelZoom(chart, evt){
    const {zoomEnabled, mode} = getOpts(chart);
    if (!zoomEnabled) return;
    const area = chart.chartArea;
    const rect = chart.canvas.getBoundingClientRect();
    const mx = evt.clientX - rect.left;
    const my = evt.clientY - rect.top;
    if (mx < area.left || mx > area.right || my < area.top || my > area.bottom) return;

    const {x: sx, y: sy} = getScales(chart, mode);
    const factor = Math.exp((evt.deltaY || 0) * 0.0015); // <1 : zoom in, >1 : zoom out
    const clampFactor = clamp(factor, 0.5, 1.5);

    if (sx){
      const cx = pixelToValue(sx, mx);
      if (cx != null){
        const min = sx.min, max = sx.max;
        const newMin = cx - (cx - min) * clampFactor;
        const newMax = cx + (max - cx) * clampFactor;
        setRange(sx, newMin, newMax);
      }
    }
    if (sy){
      const cy = pixelToValue(sy, my);
      if (cy != null){
        const min = sy.min, max = sy.max;
        const newMin = cy - (cy - min) * clampFactor;
        const newMax = cy + (max - cy) * clampFactor;
        setRange(sy, newMin, newMax);
      }
    }
    chart.update('none');
  }

  function startPan(chart, evt){
    const {panEnabled, mode} = getOpts(chart);
    if (!panEnabled) return;
    const area = chart.chartArea;
    const rect = chart.canvas.getBoundingClientRect();
    const mx = evt.clientX - rect.left;
    const my = evt.clientY - rect.top;
    if (mx < area.left || mx > area.right || my < area.top || my > area.bottom) return;

    const st = S.get(chart) || {};
    st.panning = true;
    st.start = {x: mx, y: my};
    const {x: sx, y: sy} = getScales(chart, mode);
    st.ref = {
      x: sx ? {min: sx.min, max: sx.max} : null,
      y: sy ? {min: sy.min, max: sy.max} : null
    };
    S.set(chart, st);
  }

  function movePan(chart, evt){
    const st = S.get(chart);
    if (!st || !st.panning) return;
    const {mode} = getOpts(chart);
    const rect = chart.canvas.getBoundingClientRect();
    const mx = evt.clientX - rect.left;
    const my = evt.clientY - rect.top;

    const dx = mx - st.start.x;
    const dy = my - st.start.y;

    const {x: sx, y: sy} = getScales(chart, mode);
    if (sx && st.ref.x){
      const v0 = st.ref.x.min;
      const px0 = valueToPixel(sx, v0);
      const vShift = pixelToValue(sx, px0 + dx) - v0;
      setRange(sx, st.ref.x.min - vShift, st.ref.x.max - vShift);
    }
    if (sy && st.ref.y){
      const v0 = st.ref.y.min;
      const py0 = valueToPixel(sy, v0);
      const vShift = pixelToValue(sy, py0 + dy) - v0;
      setRange(sy, st.ref.y.min - vShift, st.ref.y.max - vShift);
    }
    chart.update('none');
  }

  function endPan(chart){ const st = S.get(chart); if (st) st.panning = false; }

  const plugin = {
    id: 'zoom',
    beforeInit(chart){
      storeInitial(chart);

      // attach listeners
      const wheel = (e)=>{ e.preventDefault(); wheelZoom(chart, e); };
      const down  = (e)=>{ startPan(chart, e); };
      const move  = (e)=>{ movePan(chart, e); };
      const up    = ()=>{ endPan(chart); };

      chart.canvas.addEventListener('wheel', wheel, {passive:false});
      chart.canvas.addEventListener('mousedown', down);
      window.addEventListener('mousemove', move);
      window.addEventListener('mouseup', up);

      const st = S.get(chart) || {};
      st.listeners = {wheel, down, move, up};
      S.set(chart, st);

      // resetZoom API
      chart.resetZoom = function(){
        const st = S.get(chart) || {};
        const sx = chart.scales['x'], sy = chart.scales['y'] || chart.scales['y1'];
        if (sx && st.initX) setRange(sx, st.initX.min, st.initX.max);
        if (sy && st.initY) setRange(sy, st.initY.min, st.initY.max);
        chart.update();
      };
    },
    beforeUpdate(chart){ storeInitial(chart); },
    destroy(chart){
      const st = S.get(chart);
      if (st && st.listeners){
        const {wheel, down, move, up} = st.listeners;
        try { chart.canvas.removeEventListener('wheel', wheel); } catch {}
        try { chart.canvas.removeEventListener('mousedown', down); } catch {}
        try { window.removeEventListener('mousemove', move); } catch {}
        try { window.removeEventListener('mouseup', up); } catch {}
      }
      S.delete(chart);
    }
  };
  plugin.default = plugin;
  return plugin;
}));

