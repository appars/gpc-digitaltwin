(function (root, factory) {
  if (typeof define === 'function' && define.amd) {
    define(['chart.js'], factory);
  } else if (typeof module === 'object' && module.exports) {
    module.exports = factory(require('chart.js'));
  } else {
    root['chartjs-plugin-annotation'] = factory(root.Chart);
  }
}(this, function (Chart) {
  if (!Chart) { return {}; }

  function get(opts, path, dflt){
    try{
      const parts = path.split('.');
      let v = opts;
      for (const p of parts){ v = v[p]; if (v == null) return dflt; }
      return v;
    }catch { return dflt; }
  }

  function scaleById(chart, id){
    if (!id) return chart.scales['y'] || chart.scales['y1'];
    return chart.scales[id] || chart.scales['y'] || chart.scales['y1'];
  }

  function drawLine(ctx, x1,y1,x2,y2, style){
    ctx.save();
    ctx.beginPath();
    if (style.borderDash) ctx.setLineDash(style.borderDash);
    ctx.lineWidth = style.borderWidth || 1;
    ctx.strokeStyle = style.borderColor || 'rgba(0,0,0,0.6)';
    ctx.moveTo(x1,y1); ctx.lineTo(x2,y2); ctx.stroke();
    ctx.restore();
  }

  function drawLabel(ctx, x, y, text, style){
    if (!text) return;
    ctx.save();
    const padding = 4;
    ctx.font = '10px sans-serif';
    const metrics = ctx.measureText(text);
    const w = metrics.width + padding*2;
    const h = 14;
    const bg = get(style, 'label.backgroundColor', 'rgba(0,0,0,0.08)');
    const color = get(style, 'label.color', '#222');

    // rounded rect
    const r = 3, left = x, top = y - h;
    ctx.fillStyle = bg;
    ctx.beginPath();
    ctx.moveTo(left+r, top);
    ctx.lineTo(left+w-r, top);
    ctx.quadraticCurveTo(left+w, top, left+w, top+r);
    ctx.lineTo(left+w, top+h-r);
    ctx.quadraticCurveTo(left+w, top+h, left+w-r, top+h);
    ctx.lineTo(left+r, top+h);
    ctx.quadraticCurveTo(left, top+h, left, top+h-r);
    ctx.lineTo(left, top+r);
    ctx.quadraticCurveTo(left, top, left+r, top);
    ctx.closePath();
    ctx.fill();

    ctx.fillStyle = color;
    ctx.fillText(text, left + padding, top + h - 4);
    ctx.restore();
  }

  function drawBox(ctx, x1,y1,x2,y2, style){
    ctx.save();
    ctx.fillStyle = style.backgroundColor || 'rgba(0,0,0,0.06)';
    ctx.fillRect(x1, y1, x2-x1, y2-y1);
    ctx.restore();
  }

  const plugin = {
    id: 'annotation',
    afterDatasetsDraw(chart, args, pluginOptions){
      const ann = (pluginOptions && pluginOptions.annotations) || {};
      const keys = Object.keys(ann);
      if (!keys.length) return;

      const area = chart.chartArea;
      const xScale = chart.scales['x'];

      const ctx = chart.ctx;
      ctx.save();
      ctx.rect(area.left, area.top, area.right-area.left, area.bottom-area.top);
      ctx.clip();

      keys.forEach(key => {
        const a = ann[key] || {};
        const type = a.type || 'line';

        if (type === 'line'){
          const yScale = scaleById(chart, a.yScaleID);
          if (!yScale) return;
          const yVal = (a.yMin!=null) ? a.yMin : a.y;
          if (yVal==null) return;
          const y = yScale.getPixelForValue(yVal);
          drawLine(ctx, area.left, y, area.right, y, a);
          const lbl = get(a, 'label.content', null);
          if (lbl) drawLabel(ctx, area.left + 6, y - 6, lbl, a);
          return;
        }

        if (type === 'box'){
          const yScale = scaleById(chart, a.yScaleID);
          if (!yScale || xScale == null) return;
          let xMin = (a.xMin!=null) ? a.xMin : xScale.min;
          let xMax = (a.xMax!=null) ? a.xMax : xScale.max;
          let yMin = (a.yMin!=null) ? a.yMin : yScale.min;
          let yMax = (a.yMax!=null) ? a.yMax : yScale.max;

          // clamp super-large sentinels
          const clampInf = (v, lo, hi) => isFinite(v) ? v : (v<0 ? lo : hi);
          xMin = clampInf(xMin, xScale.min, xScale.max);
          xMax = clampInf(xMax, xScale.min, xScale.max);
          yMin = clampInf(yMin, yScale.min, yScale.max);
          yMax = clampInf(yMax, yScale.min, yScale.max);

          const x1 = xScale.getPixelForValue(xMin);
          const x2 = xScale.getPixelForValue(xMax);
          const y1 = yScale.getPixelForValue(yMax); // top
          const y2 = yScale.getPixelForValue(yMin); // bottom
          drawBox(ctx, x1, y1, x2, y2, a);
          return;
        }
      });

      ctx.restore();
    }
  };

  plugin.default = plugin;
  return plugin;
}));

